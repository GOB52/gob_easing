/*
  gob_easing lookup table example
  constexpr function, so lookup tables, etc. can be generated by compile-time calculations.
*/
#include <M5Unified.h>
#include <gob_easing.hpp>
#include <array>

// The following items were implemented after C++14 and ported for C+11
namespace gob
{
template<typename T, T... I>
struct integer_sequence
{
    using value_type = T;
    static constexpr size_t size() { return sizeof...(I); }
};
template<size_t... I> using index_sequence = integer_sequence<size_t, I...>;
	
template<typename T, size_t N, T... E> struct make_integer_sequence : make_integer_sequence<T, N-1, N-1, E...> {};
template<typename T, T... E>           struct make_integer_sequence<T, 0, E...> : integer_sequence<T, E...> {};
	
template<size_t N>      using make_index_sequence = make_integer_sequence<size_t, N>;
template<typename... T> using index_sequence_for = make_index_sequence<sizeof...(T)>;
//
}

namespace
{
// Helper of table generating
template<class Fn, std::size_t... I>
constexpr auto generate_helper(Fn f, gob::index_sequence<I...>)
        -> std::array<decltype(f(std::size_t{})), sizeof...(I)>
{
        return {{ f(I)... }};
}

template<std::size_t N, class Fn>
constexpr auto generator(Fn f) -> decltype(generate_helper(f, gob::make_index_sequence<N>{}))
{
    return generate_helper(f, gob::make_index_sequence<N>{});
}

constexpr int numberOfElements = 52;
/*
  The argument is sequence number(0,1, ... numberOfElements -1)
  So the wrapping function is created as follows.
*/
constexpr float easeInBounce(int x) { return goblib::easing::inBounce((float)x/(numberOfElements-1)); }
/*
  constexpr std::array<float, numberOfElements> =
  {
      easeInBounce(0), // t = 0/(52-1)
      easeInBounce(1), // t = 1/(52-1)
      ...
      easeInBounce(51) // t = 51/(52-1)
  };
 */
constexpr auto table = generator<numberOfElements>(easeInBounce);

auto& lcd = M5.Display;
//
}

void disp()
{
    for(auto it = table.cbegin(); it != table.cend(); ++it)
    {
        decltype(it) itn = std::next(it);
        if(it != table.cend() && itn != table.cend())
        {
            int16_t sx = std::distance(table.cbegin(), it)  * (lcd.width() / (float)(numberOfElements-1));
            int16_t ex = std::distance(table.cbegin(), itn) * (lcd.width() / (float)(numberOfElements-1));
            lcd.drawLine(sx, lcd.height() - lcd.height() * *it,
                         ex, lcd.height() - lcd.height() * *itn,
                         TFT_WHITE);
        }
    }
}

void setup()
{
    M5.begin();

    lcd.startWrite();
    lcd.setFont(&fonts::Font2);
    lcd.clear(TFT_BLACK);

    lcd.setCursor(0,0);
    lcd.printf("array.size  : %zu\n", table.size());
    lcd.printf("array.front : %f\n",  table.front());
    lcd.printf("array.back  : %f\n",  table.back());

    disp();
}

void loop()
{
    M5.update();
}

#if defined ( SDL_h_ )
__attribute__((weak)) int user_func(bool* running)
{
    setup();
    do
    {
        loop();
    } while (*running);
    return 0;
}

int main(int, char**)
{
    // The second argument is effective for step execution with breakpoints.
    // You can specify the time in milliseconds to perform slow execution that ensures screen update
    return lgfx::Panel_sdl::main(user_func, 128);
}
#endif

